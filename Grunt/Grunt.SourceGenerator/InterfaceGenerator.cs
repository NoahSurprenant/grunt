using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Collections.Generic;
//using System.Diagnostics;

namespace Grunt.SourceGenerator;

[Generator]
public class InterfaceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //System.Diagnostics.Debugger.Launch();
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is ClassDeclarationSyntax classDeclarationSyntax && classDeclarationSyntax.AttributeLists.Count > 0;

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        
        // Check if the class has the GenerateInterface attribute
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol attributeSymbol)
                {
                    if (attributeSymbol.ContainingType.Name == "GenerateInterfaceAttribute")
                    {
                        return classDeclarationSyntax;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        var distinctClasses = classes.Where(c => c is not null).Distinct();

        foreach (var classDeclaration in distinctClasses)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration!.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration!) as INamedTypeSymbol;

            if (classSymbol == null)
                continue;

            var interfaceSource = GenerateInterface(classSymbol);
            var interfaceName = $"I{classSymbol.Name}";
            
            context.AddSource($"{interfaceName}.generated.cs", SourceText.From(interfaceSource, Encoding.UTF8));

            if (interfaceName == "IHaloInfiniteClient")
            {
                var factorySource = GenerateFactoryPartial(classSymbol, interfaceName);
                context.AddSource($"HaloInfiniteClientFactory.generated.cs", SourceText.From(factorySource, Encoding.UTF8));
            }
        }
    }

    private static string GenerateFactoryPartial(INamedTypeSymbol classSymbol, string interfaceName)
    {
        // Methods
        var publicMethods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public &&
                        !m.IsStatic &&
                        m.MethodKind == MethodKind.Ordinary &&
                        !m.IsImplicitlyDeclared &&
                        !m.Name.Equals("Equals") &&
                        !m.Name.Equals("GetHashCode") &&
                        !m.Name.Equals("ToString"))
            .ToArray();

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");

        var usings = new HashSet<string> { "System", "System.Threading.Tasks", "Microsoft.Extensions.Logging" };
        CollectMethodTypeUsings(usings, publicMethods);
        // Add usings
        foreach (var u in usings.Where(u => u != namespaceName))
        {
            sb.AppendLine($"using {u};");
        }
        sb.AppendLine();

        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial class HaloInfiniteClientFactory : {interfaceName}");
        sb.AppendLine($"{{");

        foreach (var method in publicMethods)
        {
            AppendComments(sb, method);

            var returnType = GetSimpleType(method.ReturnType);
            var methodName = method.Name;
            var parameters = string.Join(", ", method.Parameters.Select(p => $"{GetSimpleType(p.Type)} {p.Name}"));
            var args = string.Join(", ", method.Parameters.Select(p => p.Name));

            // Handle generic type parameters
            var genericDeclaration = method.TypeParameters.Length > 0
                ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">"
                : "";
            var genericInvocation = method.TypeParameters.Length > 0
                ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">"
                : "";
            var typeParameterConstraints = string.Join(" ", method.TypeParameters
                .Select(tp => tp.ConstraintTypes.Length > 0
                    ? $"where {tp.Name} : {string.Join(", ", tp.ConstraintTypes.Select(GetSimpleType))}"
                    : ""));

            sb.AppendLine($"    public async {returnType} {methodName}{genericDeclaration}({parameters}) {typeParameterConstraints}");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        var client = await GetOrCreateClient().ConfigureAwait(false);");
            sb.AppendLine($"        var response = await client.{methodName}{genericInvocation}({args}).ConfigureAwait(false);");
            sb.AppendLine($"        if (response.Error.Code == 401 || response.Error.Code == 405)");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            _logger.LogWarning(\"Detected auth issue, going to retry request\");");
            sb.AppendLine($"            client = await GetOrCreateClient(true).ConfigureAwait(false);");
            sb.AppendLine($"            response = await client.{methodName}{genericInvocation}({args}).ConfigureAwait(false);");
            sb.AppendLine($"            if (response.Error.Code == 401 || response.Error.Code == 403)");
            sb.AppendLine($"            {{");
            sb.AppendLine($"                _logger.LogCritical(\"Auth retry failed!\");");
            sb.AppendLine($"            }}");
            sb.AppendLine($"        }}");
            sb.AppendLine($"        if (response.Error.Code > 299)");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            _logger.LogError(\"Status code does not indicate success: {{Code}}\", response.Error.Code);");
            sb.AppendLine($"        }}");
            sb.AppendLine($"        else");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            _logger.LogTrace(\"Status code appears successful: {{Code}}\", response.Error.Code);");
            sb.AppendLine($"        }}");
            sb.AppendLine($"        return response;");
            sb.AppendLine($"    }}");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateInterface(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var interfaceName = $"I{className}";

        var sb = new StringBuilder();
        var usings = new HashSet<string> { "System" };

        // Add header with nullable directive
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file was automatically generated by the InterfaceGenerator source generator.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Add public methods
        var publicMethods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public &&
                       !m.IsStatic &&
                       m.MethodKind == MethodKind.Ordinary &&
                       !m.IsImplicitlyDeclared &&
                       !m.Name.Equals("Equals") &&
                       !m.Name.Equals("GetHashCode") &&
                       !m.Name.Equals("ToString"))
            .ToArray();

        CollectMethodTypeUsings(usings, publicMethods);

        // Add usings
        foreach (var u in usings.Where(u => u != namespaceName))
        {
            sb.AppendLine($"using {u};");
        }
        sb.AppendLine();

        // Add namespace
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();

        // Add interface declaration
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Interface for {className}.");
        sb.AppendLine("/// This interface was automatically generated by source generator.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public interface {interfaceName}");
        sb.AppendLine("{");

        // Add public methods with XML comments
        foreach (var method in publicMethods)
        {
            AppendComments(sb, method);
            var returnType = FormatTypeForInterface(method.ReturnType, method);
            var parameters = string.Join(", ", method.Parameters.Select(p =>
                $"{FormatTypeForInterface(p.Type, method)} {p.Name}"));

            var genericParameters = "";
            if (method.TypeParameters.Length > 0)
            {
                genericParameters = "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
            }
            sb.AppendLine($"    {returnType} {method.Name}{genericParameters}({parameters});");
        }
        sb.AppendLine("}");

        return sb.ToString();
    }
    private static string GetSimpleType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
        {
            var args = string.Join(", ", namedType.TypeArguments.Select(GetSimpleType));
            return $"{namedType.Name}<{args}>";
        }
        if (string.IsNullOrEmpty(type.Name))
            return type.ToDisplayString();
        return type.Name;
    }

    private static void AppendComments(StringBuilder sb, IMethodSymbol method)
    {
        var xmlComment = method.GetDocumentationCommentXml();
        if (!string.IsNullOrWhiteSpace(xmlComment))
        {
            foreach (var line in xmlComment!.Split('\n'))
            {
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("<member") || line.StartsWith("</member"))
                    continue;
                sb.AppendLine("    /// " + line.Trim());
            }
        }
    }

    private static void CollectMethodTypeUsings(HashSet<string> usings, IMethodSymbol[] publicMethods)
    {
        foreach (var method in publicMethods)
        {
            CollectTypeUsings(usings, method.ReturnType);
            foreach (var param in method.Parameters)
            {
                CollectTypeUsings(usings, param.Type);
            }
            foreach (var tp in method.TypeParameters)
            {
                foreach (var ct in tp.ConstraintTypes)
                {
                    CollectTypeUsings(usings, ct);
                }
            }
        }
    }

    private static void CollectTypeUsings(HashSet<string> usings, ITypeSymbol type)
    {
        if (type is INamedTypeSymbol namedType)
        {
            if (!namedType.ContainingNamespace.IsGlobalNamespace)
            {
                usings.Add(namedType.ContainingNamespace.ToDisplayString());
            }
            foreach (var arg in namedType.TypeArguments)
            {
                CollectTypeUsings(usings, arg);
            }
        }
    }

    private static string FormatTypeForInterface(ITypeSymbol type, IMethodSymbol method)
    {
        // For type parameters that belong to the method, just use the name
        if (type.TypeKind == TypeKind.TypeParameter &&
            method.TypeParameters.Any(tp => tp.Name == type.Name))
        {
            return type.Name;
        }

        // For generic types that contain method type parameters, use special handling
        if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
        {
            var typeName = namedType.ConstructedFrom.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes));

            var typeArgs = namedType.TypeArguments.Select(arg => FormatTypeForInterface(arg, method));
            return $"{typeName}<{string.Join(", ", typeArgs)}>";
        }

        // For other types, use standard formatting
        return type.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));
    }
}
