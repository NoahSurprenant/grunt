using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Collections.Generic;

namespace Grunt.SourceGenerator;

[Generator]
public class InterfaceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is ClassDeclarationSyntax classDeclarationSyntax && classDeclarationSyntax.AttributeLists.Count > 0;

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        
        // Check if the class has the GenerateInterface attribute
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol attributeSymbol)
                {
                    if (attributeSymbol.ContainingType.Name == "GenerateInterfaceAttribute")
                    {
                        return classDeclarationSyntax;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        var distinctClasses = classes.Where(c => c is not null).Distinct();

        foreach (var classDeclaration in distinctClasses)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration!.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration!) as INamedTypeSymbol;

            if (classSymbol == null)
                continue;

            var interfaceSource = GenerateInterface(classSymbol);
            var interfaceName = $"I{classSymbol.Name}";
            
            context.AddSource($"{interfaceName}.generated.cs", SourceText.From(interfaceSource, Encoding.UTF8));
        }
    }

    private static string GenerateInterface(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var interfaceName = $"I{className}";

        var sb = new StringBuilder();
        var usings = new HashSet<string> { "System" };

        // Add header with nullable directive
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file was automatically generated by the InterfaceGenerator source generator.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Collect types for usings
        var allTypes = new HashSet<INamespaceSymbol>();
        void CollectTypeUsings(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                if (!namedType.ContainingNamespace.IsGlobalNamespace)
                {
                    usings.Add(namedType.ContainingNamespace.ToDisplayString());
                }
                foreach (var arg in namedType.TypeArguments)
                {
                    CollectTypeUsings(arg);
                }
            }
        }

        // Add public properties
        var publicProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToArray();

        foreach (var property in publicProperties)
        {
            CollectTypeUsings(property.Type);
        }

        // Add public methods
        var publicMethods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public && 
                       !m.IsStatic && 
                       m.MethodKind == MethodKind.Ordinary &&
                       !m.IsImplicitlyDeclared &&
                       !m.Name.Equals("Equals") &&
                       !m.Name.Equals("GetHashCode") &&
                       !m.Name.Equals("ToString"))
            .ToArray();

        foreach (var method in publicMethods)
        {
            CollectTypeUsings(method.ReturnType);
            foreach (var param in method.Parameters)
            {
                CollectTypeUsings(param.Type);
            }
        }

        // Add usings
        foreach (var u in usings.Where(u => u != namespaceName))
        {
            sb.AppendLine($"using {u};");
        }
        sb.AppendLine();

        // Add namespace
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();

        // Add interface declaration
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Interface for {className}.");
        sb.AppendLine("/// This interface was automatically generated by source generator.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public interface {interfaceName}");
        sb.AppendLine("{");

        // Add public properties with XML comments
        foreach (var property in publicProperties)
        {
            var xmlComment = property.GetDocumentationCommentXml();
            if (!string.IsNullOrWhiteSpace(xmlComment))
            {
                foreach (var line in xmlComment!.Split('\n'))
                {
                    if (string.IsNullOrWhiteSpace(line) || line.StartsWith("<member"))
                        continue;
                    sb.AppendLine("    /// " + line.Trim());
                }
            }
            var propertyType = property.Type.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));
            var accessors = new List<string>();
            if (property.GetMethod?.DeclaredAccessibility == Accessibility.Public)
                accessors.Add("get;");
            if (property.SetMethod?.DeclaredAccessibility == Accessibility.Public)
                accessors.Add("set;");
            if (accessors.Count > 0)
            {
                sb.AppendLine($"    {propertyType} {property.Name} {{ {string.Join(" ", accessors)} }}");
            }
        }
        if (publicProperties.Length > 0)
        {
            sb.AppendLine();
        }

        // Add public methods with XML comments
        foreach (var method in publicMethods)
        {
            var xmlComment = method.GetDocumentationCommentXml();
            if (!string.IsNullOrWhiteSpace(xmlComment))
            {
                foreach (var line in xmlComment!.Split('\n'))
                {
                    if (string.IsNullOrWhiteSpace(line) || line.StartsWith("<member"))
                        continue;
                    sb.AppendLine("    /// " + line.Trim());
                }
            }
            var returnType = FormatTypeForInterface(method.ReturnType, method);
            var parameters = string.Join(", ", method.Parameters.Select(p =>
                $"{FormatTypeForInterface(p.Type, method)} {p.Name}"));

            var genericParameters = "";
            if (method.TypeParameters.Length > 0)
            {
                genericParameters = "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
            }
            sb.AppendLine($"    {returnType} {method.Name}{genericParameters}({parameters});");
        }
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string FormatTypeForInterface(ITypeSymbol type, IMethodSymbol method)
    {
        // For type parameters that belong to the method, just use the name
        if (type.TypeKind == TypeKind.TypeParameter &&
            method.TypeParameters.Any(tp => tp.Name == type.Name))
        {
            return type.Name;
        }

        // For generic types that contain method type parameters, use special handling
        if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
        {
            var typeName = namedType.ConstructedFrom.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes));

            var typeArgs = namedType.TypeArguments.Select(arg => FormatTypeForInterface(arg, method));
            return $"{typeName}<{string.Join(", ", typeArgs)}>";
        }

        // For other types, use standard formatting
        return type.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));
    }
}
