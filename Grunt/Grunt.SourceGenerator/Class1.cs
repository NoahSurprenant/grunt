using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Grunt.SourceGenerator;

[Generator]
public class InterfaceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is ClassDeclarationSyntax classDeclarationSyntax && classDeclarationSyntax.AttributeLists.Count > 0;

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        
        // Check if the class has the GenerateInterface attribute
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol attributeSymbol)
                {
                    if (attributeSymbol.ContainingType.Name == "GenerateInterfaceAttribute")
                    {
                        return classDeclarationSyntax;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        var distinctClasses = classes.Where(c => c is not null).Distinct();

        foreach (var classDeclaration in distinctClasses)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration!.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration!) as INamedTypeSymbol;

            if (classSymbol == null)
                continue;

            var interfaceSource = GenerateInterface(classSymbol);
            var interfaceName = $"I{classSymbol.Name}";
            
            context.AddSource($"{interfaceName}.generated.cs", SourceText.From(interfaceSource, Encoding.UTF8));
        }
    }

    private static string GenerateInterface(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var interfaceName = $"I{className}";

        var sb = new StringBuilder();
        
        // Add header with nullable directive
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file was automatically generated by the InterfaceGenerator source generator.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        
        // Add usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Surprenant.Grunt.Models;");
        sb.AppendLine("using Surprenant.Grunt.Models.HaloInfinite;");
        sb.AppendLine("using Surprenant.Grunt.Models.HaloInfinite.ApiIngress;");
        sb.AppendLine("using Surprenant.Grunt.Models.HaloInfinite.Medals;");
        sb.AppendLine();
        
        // Add namespace
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        
        // Add interface declaration
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Interface for {className}.");
        sb.AppendLine("/// This interface was automatically generated by source generator.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public interface {interfaceName}");
        sb.AppendLine("{");

        // Add public properties
        var publicProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToArray();

        foreach (var property in publicProperties)
        {
            var propertyType = GetFullyQualifiedTypeName(property.Type);
            var accessors = new System.Collections.Generic.List<string>();
            
            if (property.GetMethod?.DeclaredAccessibility == Accessibility.Public)
                accessors.Add("get;");
            if (property.SetMethod?.DeclaredAccessibility == Accessibility.Public)
                accessors.Add("set;");

            if (accessors.Count > 0)
            {
                sb.AppendLine($"    {propertyType} {property.Name} {{ {string.Join(" ", accessors)} }}");
            }
        }

        // Add blank line between properties and methods if we have properties
        if (publicProperties.Length > 0)
        {
            sb.AppendLine();
        }

        // Add public methods
        var publicMethods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public && 
                       !m.IsStatic && 
                       m.MethodKind == MethodKind.Ordinary &&
                       !m.IsImplicitlyDeclared &&
                       !m.Name.Equals("Equals") &&
                       !m.Name.Equals("GetHashCode") &&
                       !m.Name.Equals("ToString"))
            .ToArray();

        foreach (var method in publicMethods)
        {
            var returnType = GetFullyQualifiedTypeName(method.ReturnType);
            var parameters = string.Join(", ", method.Parameters.Select(p => 
                $"{GetFullyQualifiedTypeName(p.Type)} {p.Name}"));

            // Handle generic methods
            var genericParameters = "";
            if (method.TypeParameters.Length > 0)
            {
                genericParameters = "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
            }

            sb.AppendLine($"    {returnType} {method.Name}{genericParameters}({parameters});");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetFullyQualifiedTypeName(ITypeSymbol type)
    {
        // For type parameters, just return the name
        if (type.TypeKind == TypeKind.TypeParameter)
        {
            return type.Name;
        }

        return type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }
}
